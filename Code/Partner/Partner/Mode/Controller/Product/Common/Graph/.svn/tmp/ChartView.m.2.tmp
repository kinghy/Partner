//
//  ChartView.m
//  chart
//
//  Created by  rjt on 15/5/27.
//  Copyright (c) 2015年 JYZD. All rights reserved.
//

#import "ChartView.h"
#import "Grid.h"

@interface ChartView(){
    float margin_left;
    float margin_right;
    float margin_top;
    float margin_bottom;
    float x_hieight;
    
    int minutes;
    NSArray* splittime;//时间分割
    NSArray* splitdiffer;//每个点之间的间隔分钟
    
    int percent;
    float mult;//比例放大因子
    float multheight;//高度放大因子
    float multwidth;//宽度放大因子
    
    BOOL _fullSize ;
    
    int h_fill;
    int allpoitnt;
    
    CAShapeLayer * mainlayer;
    
    NSMutableArray * pricelines;//基准线
    NSMutableArray * vollines;//基准线
    CAShapeLayer * filllayer;//填充色
    CAShapeLayer * linelayer;//折线
    
    CAShapeLayer * chartlayer;
    CAShapeLayer * vollayer;
    CALayer * xlabellayer;
    
    CALayer *rectlayer;
    
    NSMutableArray* grids;//模型二维数组
    NSMutableArray* points;//有值得grid
    
    float abshigh;//当前波动的绝对峰值
    float abshighprice;//当前波动的绝对峰值
    
    float _close;//昨收价
    float _high;//最高价
    float _low; //最低价
    float _open;//开盘价
    
    NSArray* _prices;//价格列表
    NSArray* _vols;//交易量列表
    NSString* _time;//市场时间
    
    
    CALayer *cycle;                 //最新价，跳动的圆
    int times;
    NSTimer *timer;
    BOOL isFirstPrice;
    BOOL isFirstVol;
}

@end

@implementation ChartView

-(void)awakeFromNib{
    isFirstPrice = YES;
    isFirstVol = YES;
    
    pricelines = [[NSMutableArray alloc] init];
    vollines = [[NSMutableArray alloc] init];
    margin_left = 0;
    margin_right= 0;
    margin_top = 0;
    margin_bottom = 0;
    x_hieight = 15;
    h_fill = 5;//填充10个格子
    
    percent = 200  + 1;//上下各20点,加上0线
    
    allpoitnt = percent + h_fill*2;
    
    mainlayer = [CAShapeLayer layer];

    chartlayer = [CAShapeLayer layer];
    //绘制图表边框
    chartlayer.borderWidth = 1;
    chartlayer.borderColor = GRAY_LINE_COLOR.CGColor;
    chartlayer.contentsGravity = kCAGravityResizeAspect;
    
    vollayer = [CAShapeLayer layer];
    //绘制图表边框
    vollayer.borderWidth = 1;
    vollayer.borderColor = GRAY_LINE_COLOR.CGColor;
    vollayer.contentsGravity = kCAGravityResizeAspect;
    
    //绘制原点
    if (cycle==nil) {
        cycle = [CALayer layer];
        UIImage *img = [UIImage imageNamed:@"dotcycle.png"];
        cycle.frame = CGRectMake(-100, -100, img.size.width, img.size.height);
        cycle.contents = (__bridge id)(img.CGImage);
        cycle.zPosition = 100;
        cycle.hidden = YES;
        //        cycle.position = CGPointMake(cycle.position.x+(img.size.width/2), cycle.position.y+(img.size.height/2));
        [chartlayer addSublayer:cycle];
    }
    times = -1;
    
    xlabellayer = [CALayer layer];
    
    [mainlayer addSublayer:chartlayer];
    [mainlayer addSublayer:vollayer];
    [mainlayer addSublayer:xlabellayer];
    
    CGRect frame = self.frame;
    if(iPhone4 ){
        frame.size.width=307;
        frame.size.height = 168;
    }else if(iPhone5){
        frame.size.width=307;
        frame.size.height = 245;
    }
    else if(iPhone6Plus){
        frame.size.width=397;
    }
    mainlayer.frame = CGRectMake(margin_left, margin_top, frame.size.width - margin_left - margin_right, frame.size.height - margin_top - margin_bottom);
    
    [self.layer addSublayer:mainlayer];
    
    
    
    points = [[NSMutableArray alloc] init];
}


-(void)left2rightPrice{
    CABasicAnimation *animation = [CABasicAnimation animation];
    animation.duration = 1.f;
    animation.keyPath = @"bounds.size.width";
    animation.fromValue = @0;
    
    animation.toValue = [[NSNumber alloc] initWithFloat:chartlayer.frame.size.width];
    
    animation.removedOnCompletion = NO;
    animation.fillMode = kCAFillModeForwards;
    [filllayer addAnimation:animation forKey:nil];
    [linelayer addAnimation:animation forKey:nil];
    
    [self performSelector:@selector(showCycle) withObject:nil afterDelay:.7f ];
}

-(void)left2rightVol{
    CABasicAnimation *animation = [CABasicAnimation animation];
    animation.duration = 1.f;
    animation.keyPath = @"bounds.size.width";
    animation.fromValue = @0;
    
    animation.toValue = [[NSNumber alloc] initWithFloat:vollayer.frame.size.width];
    
    animation.removedOnCompletion = NO;
    animation.fillMode = kCAFillModeForwards;
    [rectlayer addAnimation:animation forKey:nil];
}

/*!
 *  @brief  绘制分时图
 */
-(void)drawPrice{
    //清除基准线
    for (int i = 0;i<pricelines.count;++i) {
        CALayer* layer = (CALayer*)pricelines[i];
        [layer removeFromSuperlayer];
        //        [dashlines removeObject:layer];
        
    }
    [points removeAllObjects];
    [pricelines removeAllObjects];
    if(_prices){
        CGRect frame = mainlayer.frame;

        if (_fullSize) {
            chartlayer.frame = CGRectMake(0, 0, frame.size.width+1, (frame.size.height - x_hieight));
        }else{
            chartlayer.frame = CGRectMake(0, 0, frame.size.width+1, (frame.size.height - x_hieight)*0.72);
        }
       
        //绘制图表边框
        chartlayer.borderWidth = 1;
        chartlayer.borderColor = GRAY_LINE_COLOR.CGColor;
        chartlayer.contentsGravity = kCAGravityResizeAspect;
        
        xlabellayer.frame = CGRectMake(0, frame.size.height-x_hieight, frame.size.width, x_hieight);
        //绘制图表边框
        //    xlabellayer.borderWidth = 1;
        //    xlabellayer.borderColor = [UIColor redColor].CGColor;
        //算基准线
        
        if(_high!=0){//未开盘，微调
            abshighprice = fabs(_high-_close)>=fabs(_low-_close)?fabs(_high-_close):fabs(_low-_close);
        }else{
            abshighprice = 0.005*_close;
        }
        
        abshigh = abshighprice*1000/_close;
        if(abshigh!=0){
            mult = (percent-1)/2/abshigh;
        }else{
            mult = 0;
        }
        multheight = chartlayer.frame.size.height/allpoitnt;
        
        multwidth = chartlayer.frame.size.width/minutes;
        
        CGPoint basePoint= CGPointMake(0, ((allpoitnt-1)/2+1)*multheight);
        
        for (long i = 0; i<[_prices count]; ++i) {
            NSNumber *price = (NSNumber*)_prices[i];
            Grid *g = [[Grid alloc] init];
            g.percent = ([price floatValue]-_close)*100/_close;
            g.price = [price floatValue];
            g.x_grid = i ;
            [points addObject:g];
        }
        
        
        UIBezierPath* bezier = [UIBezierPath bezierPath];
        
        CGPoint beginPoint = CGPointMake(0, chartlayer.frame.size.height);
        CGPoint lastestPoint = CGPointMake(0, 0);
        
        for (int i = 0; i<[points count]; ++i) {
            Grid *g = (Grid*)points[i];
            CGPoint p = [g getPointWithBasePoint:basePoint multWidth:multwidth multHeight:multheight*mult ];
            //        NSLog(@"p.x = %f; p.y = %f ,x = %d ,y=%d ",p.x, p.y);
            if (i==0) {
                [bezier moveToPoint:p];
            }else{
                [bezier addLineToPoint:p];
            }
            lastestPoint = p;
        }
        //将点移到最后一分钟的位置
        if (lastestPoint.x>0 && lastestPoint.x<(chartlayer.frame.size.width-1) && _high > 0) {//判断是否开盘
            cycle.frame = CGRectMake(lastestPoint.x-cycle.frame.size.width/2, lastestPoint.y-cycle.frame.size.height/2, cycle.frame.size.width, cycle.frame.size.height);
            if(cycle.hidden && times>=0 && !isFirstVol){
                cycle.hidden=NO;
            }
        }else{
            cycle.hidden = YES;
        }
        [linelayer removeFromSuperlayer];
        linelayer = [CAShapeLayer layer];
        linelayer.path = bezier.CGPath;
        linelayer.lineWidth = 1;
        linelayer.strokeColor = [[UIColor colorWithRed:11/255.0 green:125/255.0 blue:213/255.0 alpha:1.0] CGColor];
        linelayer.fillColor = [UIColor clearColor].CGColor;
        linelayer.lineJoin = kCALineJoinRound;
        linelayer.lineCap = kCALineCapRound;
        linelayer.frame = chartlayer.bounds;
        linelayer.masksToBounds = YES;
        linelayer.position =  CGPointMake(0,linelayer.position.y);
        linelayer.anchorPoint = CGPointMake(0,linelayer.anchorPoint.y);
        [chartlayer addSublayer:linelayer];
        [bezier addLineToPoint:CGPointMake(lastestPoint.x, beginPoint.y)];
        [bezier addLineToPoint:CGPointMake(beginPoint.x, beginPoint.y)];
        //[bezier moveToPoint:CGPointMake(lastestPoint.x, bgpoint.y)];
        [bezier closePath];
        [filllayer removeFromSuperlayer];
        filllayer = [CAShapeLayer layer];
        filllayer.path = bezier.CGPath;
        filllayer.strokeColor = [UIColor clearColor].CGColor;
        filllayer.fillColor = [[UIColor colorWithRed:219/255.0 green:239/255.0 blue:255/255.0 alpha:1.0] CGColor];
        filllayer.zPosition = 0;
        filllayer.frame = chartlayer.bounds;
        filllayer.masksToBounds = YES;
        filllayer.position =  CGPointMake(0,filllayer.position.y);
        filllayer.anchorPoint = CGPointMake(0,filllayer.anchorPoint.y);
        [chartlayer addSublayer:filllayer];
        
        //初次进入的动画效果
        CGRect rect = chartlayer.bounds;
        rect.size.width = 0;
        if (_prices.count>0 && isFirstPrice) {
            isFirstPrice = NO;
            filllayer.frame = rect;
            linelayer.frame = rect;
            
            [self performSelector:@selector(left2rightPrice) withObject:nil afterDelay:1.f];
        }
        //[chartlayer addSublayer:filllayer];
        //    Grid *t = [[Grid alloc] init];
        //    t.x_grid = 0;
        //    t.y_grid = (percent - 1)/2+1;
        //
        //    CGPoint basepoint = [t getPointWithOrigin:origin width:gridwidth hieght:gridheight scaleOrigin:originpoint];
        //
        //    //基线
        [self drawHLine:basePoint width:chartlayer.frame.size.width price:_close percent:0 isDash:NO];
        [self drawHLine:CGPointMake(0, 0) width:chartlayer.frame.size.width price:_close+abshighprice percent:abshighprice*100/_close isDash:YES];
        
        [self drawHLine:beginPoint width:chartlayer.frame.size.width price:_close-abshighprice percent:(abshighprice*(-1))*100/_close isDash:YES];
        
        [self drawHLine:CGPointMake(0, basePoint.y/2) width:chartlayer.frame.size.width price:_close+abshighprice/2 percent:(abshighprice/2)*100/_close isDash:YES];
        
        [self drawHLine:CGPointMake(0, basePoint.y/2+basePoint.y) width:chartlayer.frame.size.width price:_close-abshighprice/2 percent:(abshighprice/2*(-1))*100/_close isDash:YES];
        
        //计算时间分割
        for (int i = 0 ; i<splittime.count; ++i) {
            float split = [(NSNumber*)splitdiffer[i] floatValue]/(minutes-1)*xlabellayer.frame.size.width;
            [self drawTime:CGPointMake(split,0 ) width:30 date:splittime[i]];
        }
    }
}

/**
 绘制成交量
 */
-(void)drawVol{
    //清除基准线
    for (int i = 0;i<vollines.count;++i) {
        CALayer* layer = (CALayer*)vollines[i];
        [layer removeFromSuperlayer];
        //        [dashlines removeObject:layer];
        
    }
    [vollines removeAllObjects];
    
    //开始绘制
    CGRect frame = mainlayer.frame;
    
    vollayer.frame = CGRectMake(0, (frame.size.height - x_hieight)*0.72, frame.size.width+1, (frame.size.height - x_hieight)*0.28);
    //绘制图表边框
    vollayer.borderWidth = 1;
    vollayer.borderColor = GRAY_LINE_COLOR.CGColor;
    vollayer.contentsGravity = kCAGravityResizeAspect;
    vollayer.hidden = NO;
    
    rectlayer = [CALayer layer];
    rectlayer.frame = vollayer.bounds;
    
    float max=0;
    for (int i=0; i<_vols.count; ++i) {
        NSArray * arr = (NSArray*)_vols[i];//第一个是价格 第二个是成交量
//      float vol = ([arr[1] floatValue]<0 || [arr[1] floatValue]  > 1000000)?0:[arr[1] floatValue];
        float vol = ([arr[1] floatValue]<0)?0:[arr[1] floatValue];
        max = max<vol?vol:max;
    }
    
    float ph = max>0?(vollayer.frame.size.height-3)/max:0;
    float pw = (vollayer.frame.size.width)/minutes;
    
    for (int i=0; i<_vols.count; ++i) {
        NSArray * arr = (NSArray*)_vols[i];//第一个是价格 第二个是成交量
        CAShapeLayer *volvaluelayer = [CAShapeLayer layer];
        volvaluelayer.backgroundColor = Color_Bg_Blue.CGColor;
        
//        volvaluelayer.backgroundColor = [arr[0] floatValue]>=_close?Color_Bg_Red.CGColor:Color_Bg_Green.CGColor;
//        float vol = ([arr[1] floatValue]<0 || [arr[1] floatValue]  > 1000000)?0:[arr[1] floatValue];
        float vol = ([arr[1] floatValue]<0)?0:[arr[1] floatValue];
        volvaluelayer.frame = CGRectMake(pw*i,vollayer.frame.size.height - ph*vol,1,ph*vol);
        [vollines addObject:volvaluelayer];
        [rectlayer addSublayer:volvaluelayer];
    }
    rectlayer.masksToBounds = YES;
    rectlayer.position =  CGPointMake(0,rectlayer.position.y);
    rectlayer.anchorPoint = CGPointMake(0,rectlayer.anchorPoint.y);
    [vollines addObject:rectlayer];
    [vollayer addSublayer:rectlayer];
    
    
    //初次进入的动画效果
    CGRect rect = vollayer.bounds;
    rect.size.width = 0;
    if (_vols.count>0 && isFirstVol) {
        isFirstVol = NO;
        rectlayer.frame = rect;
        [self performSelector:@selector(left2rightVol) withObject:nil afterDelay:1.f];
    }
    
    //画中线
    UIBezierPath *path = [UIBezierPath bezierPath];
    [path moveToPoint:CGPointMake(0,0)];
    [path addLineToPoint:CGPointMake(vollayer.frame.size.width,0) ];
    
    CAShapeLayer *shapeLayer = [CAShapeLayer layer];
    shapeLayer.frame = CGRectMake(0, vollayer.frame.size.height/2, vollayer.frame.size.width, 1);
    
    CATextLayer* volvaluelayer = [CATextLayer layer];
    if (max > 10000) {
        volvaluelayer.string = [NSString stringWithFormat:@"%.2f万",max/100/10000];
    }else{
        volvaluelayer.string = [NSString stringWithFormat:@"%.0f",max/100];
    }
    
    volvaluelayer.foregroundColor = [[UIColor grayColor] CGColor];
    
    volvaluelayer.contentsScale = 2;
    volvaluelayer.fontSize = 10.f; //字体的大小
    volvaluelayer.alignmentMode = kCAAlignmentLeft;//字体的对齐方式
    volvaluelayer.frame =CGRectMake(5, 5, 100, 14);

    [vollines addObject:shapeLayer];
    [vollines addObject:volvaluelayer];
    
    [vollayer addSublayer:shapeLayer];
    [vollayer addSublayer:volvaluelayer];
}

/**
 绘制虚线
 */
-(void)drawHLine:(CGPoint)origin width:(CGFloat)w price:(float)price percent:(float)per isDash:(BOOL)isdash{
    
    UIBezierPath *path = [UIBezierPath bezierPath];
    [path moveToPoint:CGPointMake(0,0)];
    [path addLineToPoint:CGPointMake(w,0) ];
    
    CAShapeLayer *shapeLayer = [CAShapeLayer layer];
    shapeLayer.frame = CGRectMake(origin.x, origin.y, w, 1);

    
    CATextLayer* pricelayer = [CATextLayer layer];
    pricelayer.string = [NSString stringWithFormat:@"%.2f",price];
    if(per==0){
        pricelayer.foregroundColor = [[UIColor grayColor] CGColor];
    }else if(per>0){
        pricelayer.foregroundColor = Color_Bg_Red.CGColor;
    }else{
        pricelayer.foregroundColor = Color_Bg_Green.CGColor;
    }

    pricelayer.contentsScale = 2;
    pricelayer.fontSize = 10.f; //字体的大小
    pricelayer.alignmentMode = kCAAlignmentLeft;//字体的对齐方式
   
    
    CATextLayer* percentlayer = [CATextLayer layer];
    
    if(per==0){
        percentlayer.string = [NSString stringWithFormat:@"%.2f%%",per];
        percentlayer.foregroundColor = [[UIColor grayColor] CGColor];
    }else if(per>0){
        percentlayer.string = [NSString stringWithFormat:@"+%.2f%%",per];
        percentlayer.foregroundColor = Color_Bg_Red.CGColor;
    }else{
        percentlayer.string = [NSString stringWithFormat:@"-%.2f%%",per];
        percentlayer.foregroundColor = Color_Bg_Green.CGColor;
    }
    
    
    if(origin.y-14 < 0){
        pricelayer.frame =CGRectMake(origin.x+5, origin.y+5, 80, 14);
        percentlayer.frame = CGRectMake(w-105, origin.y+5 , 100, 14);
    }else if(origin.y+14 > chartlayer.frame.size.height){
        pricelayer.frame =CGRectMake(origin.x+5, origin.y-14 , 80, 14);
        percentlayer.frame = CGRectMake(w-105, origin.y-14 , 100, 14);
    }else{
        pricelayer.frame =CGRectMake(origin.x+5, origin.y-7 , 80, 14);
        percentlayer.frame = CGRectMake(w-105, origin.y-7 , 100, 14);
        [shapeLayer setFillColor:[[UIColor clearColor] CGColor]];
        // 设置虚线颜色为blackColor [shapeLayer setStrokeColor:[[UIColor blackColor] CGColor]];
        [shapeLayer setStrokeColor:[[UIColor colorWithRed:223/255.0 green:223/255.0 blue:223/255.0 alpha:1.0f] CGColor]];
        // 3.0f设置虚线的宽度 [shapeLayer setLineWidth:1.0f];
        [shapeLayer setLineJoin:kCALineJoinRound];
        if (isdash) {
            // 1=线的宽度 1=每条线的间距
            [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:3],[NSNumber numberWithInt:3],nil]];
        }
        
        shapeLayer.path = path.CGPath;
    }

    percentlayer.contentsScale = 2;
    percentlayer.fontSize = 10.f; //字体的大小
    percentlayer.alignmentMode = kCAAlignmentRight;//字体的对齐方式
    
    [pricelines addObject:pricelayer];
    [pricelines addObject:percentlayer];
    [pricelines addObject:shapeLayer];

    [chartlayer addSublayer:shapeLayer];
    [chartlayer addSublayer:pricelayer];
    [chartlayer addSublayer:percentlayer];
    
}

-(void)drawTime:(CGPoint)origin width:(CGFloat)w date:(NSDate*)date{
    CATextLayer* timelayer = [CATextLayer layer];
    
    if (origin.x<=0) {
        timelayer.frame =CGRectMake(origin.x, 1 , w, 14);
        timelayer.alignmentMode = kCAAlignmentLeft;//字体的对齐方式
    }else if (origin.x>=xlabellayer.frame.size.width) {
        timelayer.frame =CGRectMake(origin.x-w, 1 , w, 14);
        timelayer.alignmentMode = kCAAlignmentRight;//字体的对齐方式
    }else{
        timelayer.frame =CGRectMake(origin.x-w/2, 1 , w, 14);
        timelayer.alignmentMode = kCAAlignmentCenter;//字体的对齐方式
    }
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    //设定时间格式,这里可以设置成自己需要的格式
    [dateFormatter setDateFormat:@"HH:mm"];
    timelayer.string = [dateFormatter stringFromDate:date];
    timelayer.foregroundColor = [[UIColor grayColor] CGColor];
    timelayer.contentsScale = 2;
    timelayer.fontSize = 10.f; //字体的大小
    
    
    [pricelines addObject:timelayer];
    
    [xlabellayer addSublayer:timelayer];

}



-(void)drawChartWithPrices:(NSArray*)prices
                    yClose:(NSString*)close
                 highPrice:(NSString*)high
                  lowPrice:(NSString*)low
                 openPrice:(NSString*)open
                      time:(NSString*)time
                allMinutes:(int)min
                 fullSize:(BOOL)fullSize
                spliteTime:(NSArray*) sptime
               splitDiffer:(NSArray*) spdiffer{
    _close = [close floatValue];
    _high = [high floatValue];
    _low = [low floatValue];
    _open = [open floatValue];
    _time = time;
    _prices = prices;
    _fullSize = fullSize;
    minutes = min;
    splittime = sptime;
    splitdiffer = spdiffer;
   
    [CATransaction begin];
    ///关闭隐式动画
    [CATransaction setDisableActions:YES];
    [self drawPrice];
    
    [CATransaction commit];
    
}

-(void)drawChartWithVols:(NSArray*)vols
                allMinutes:(int)min
                spliteTime:(NSArray*) sptime
               splitDiffer:(NSArray*) spdiffer{
    _vols = vols;
    minutes = min;
    splittime = sptime;
    splitdiffer = spdiffer;
    [CATransaction begin];
    ///关闭隐式动画
    [CATransaction setDisableActions:YES];
    [self drawVol];
    [CATransaction commit];
}


-(void) showCycle{
    cycle.hidden=NO;
}

-(void)changeCycle{
    times++;
    times = times%2;
    if (times == 1) {
        cycle.affineTransform = CGAffineTransformMakeScale(1.3f,1.3f);
        //lay.frame = CGRectMake(100, 100, lay.frame.size.width+5, lay.frame.size.width+5);
    }else{
        cycle.affineTransform = CGAffineTransformMakeScale(1.f,1.f);
        //lay.frame = CGRectMake(100, 100, lay.frame.size.width-5, lay.frame.size.width-5);
    }
}

-(void)startPulse{//开启最新价跳动
    times ++;
    if (timer==nil) {
        timer = [NSTimer scheduledTimerWithTimeInterval:.5f target:self selector:@selector(changeCycle) userInfo:nil repeats:YES];
    }
    
}
-(void)endPulse{//关闭最新价跳动
    cycle.hidden = YES;
    times = -1;
    if (timer!=nil) {
        [timer invalidate];
    }
}

/*
// Only override drawRect: if you perform custom drawing.
// An empty implementation adversely affects performance during animation.
- (void)drawRect:(CGRect)rect {
    // Drawing code
}
*/

-(void)dealloc{
    NSLog(@"%@ has dealloc",[self class]);
}

@end
